__author__ = "Enrique Fernandez Sanchez (efernandez@e-lighthouse.com)"
__credits__ = ["Enrique Fernandez Sanchez"]
__version__ = "1.2"
__maintainer__ = "Enrique Fernandez Sanchez"
__email__ = "efernandez@e-lighthouse.com"
__status__ = "Validated"

from enum import Enum
import numpy as np

class Weather(Enum):
    SUNNY = 1.0   # No reduction in irradiance for sunny day
    CLOUDY = 0.5  # 50% reduction in irradiance for cloudy day [20-50% less]
    RAINY = 0.1   # 90% reduction in irradiance for rainy day [80-90% less]



class SolarPanel:
    
    DEFAULT_DAY_NIGHT_SUN_PROFILE = {
        "day_night_cycle_profile_type": "gaussiana_finde_pulso",
        "base_val": 0.0,
        "peak_val": 1.0,
        "transition_width": 3/4 * 3600,
        "rising_start_hour": 6,
        "rising_end_hour": 12,
        "falling_start_hour": 16,
        "falling_end_hour": 21,
    }
    
    
    # > Go to this website: https://globalsolaratlas.info/
    # > Select a place, and save the value of GHI *per Day*
    # -> Example: Cartagena, GHI per Day: 4.900 kWh/m2
    irradiance_city = {
        "Cartagena": 0.980,   # kWh/m2 -> mean of two peak hours, summer, sunny day
    }

    
    # > Go to this website: https://globalsolaratlas.info/
    # > Select a place, and save the value of GTI *per Day*
    # -> Example: Cartagena, GTI per Day: 5.73 kWh/m2
    gti_city = {
        "Cartagena": 5.55, # kWh/m2 by day
    }
    
    # GTI is the most adecuate value to use for this solar panel, as it is the value of the solar irradiance in the plane of the panel
    # including estimations of the atmosphere, and the angle of the sun, considering that the panel is fixed and not rotating
    
    
    
    def __init__(
        self, 
        power_rating, 
        voltage_charging, 
        efficiency, 
        area,
        irradiance_city: str = "Cartagena",
        day_night_cycle_profile_config: dict = DEFAULT_DAY_NIGHT_SUN_PROFILE
    ):
        self.power_rating = power_rating            # Panel's power rating in Watts (10W) 
        self.voltage_charging = voltage_charging    # Panel's Voltage charging to battery
        self.efficiency = efficiency                # Panel's efficiency as decimal (0.15 == 15%)
        self.area = area                            # Panel's area in square meters (0.10 == 0.1m2)
        
        
        # Configure time limits for the day-night cycle profile
        self.day_night_cycle_profile_config = day_night_cycle_profile_config
        
        self.rise_t_start = day_night_cycle_profile_config.get("rising_start_hour", 6) * 3600
        self.rise_t_end = day_night_cycle_profile_config.get("rising_end_hour", 12) * 3600
        self.fall_t_start = day_night_cycle_profile_config.get("falling_start_hour", 16) * 3600
        self.fall_t_end = day_night_cycle_profile_config.get("falling_end_hour", 21) * 3600
        
        # Preconfigure the curve parameters
        self.rising_mid = (self.rise_t_start + self.rise_t_end) / 2
        self.falling_mid = (self.fall_t_start + self.fall_t_end) / 2
        self.base_val = day_night_cycle_profile_config.get("base_val", 0.0)
        self.peak_val = day_night_cycle_profile_config.get("peak_val", 1.0)
        self.transition_width = day_night_cycle_profile_config.get("transition_width", 3600)
        
        self.irradiance_city = irradiance_city
    
    
    def calculate_power_generated(self, solar_irradiance, timeStep: int, weather_condition: Weather = Weather.SUNNY) -> float:
        """
        Calculate the power generated by the solar panel based on solar irradiance and weather condition.
        :param solar_irradiance: Solar irradiance in kWh/m² per day
        :param timeStep: simulation steps in seconds (s)
        :param weather_condition: Enum value from Weather (SUNNY, CLOUDY, RAINY)
        :return: Power generated in Watts (W)
        """
        solar_irradiance = solar_irradiance * 1000  # Convert kWh to Wh
        adjusted_irradiance = solar_irradiance * weather_condition.value
        
        power_generated = adjusted_irradiance * self.area * self.efficiency
        power_generated_timeStep = (power_generated / 3600) * timeStep
        
        return power_generated_timeStep  # In Watts (W)
    
    def calculate_current(self, solar_irradiance, timeStep: int, weather_condition : Weather = Weather.SUNNY) -> float:
        """
        Calculate the current generated by the solar panel based on solar irradiance and weather condition.
        :param solar_irradiance: Solar irradiance in hW/m² per day
        :param timeStep: simulation steps in seconds (s)
        :param weather_condition: Enum value from Weather (SUNNY, CLOUDY, RAINY)
        :return: Current in amperes (A)
        """
        solar_irradiance = solar_irradiance * 1000  # Convert kWh to Wh
        current = self.calculate_power_generated(solar_irradiance, timeStep=timeStep, weather_condition=weather_condition) / self.power_rating
        return current  # In Amperes (A)
    
    def calculate_Ah_in_timeStep(self, solar_irradiance, timeStep: int, weather_condition : Weather = Weather.SUNNY):
        """
        Calculate the Amperes Hours of a solara panel, based on the irradiance and the weather conditions
        :param solar_irradiance: Solar irradiance in khW/m² per day
        :param timeStep: simulation steps in seconds (s)
        :param weather_condition: Enum value from Weather (SUNNY, CLOUDY, RAINY)
        :return: Current in amperes hour (Ah)
        """
        charging_power = self.calculate_power_generated(solar_irradiance=solar_irradiance, timeStep=timeStep, weather_condition=weather_condition)
        return charging_power / self.voltage_charging   # In Amperes Hour (Ah)

    @staticmethod
    def _sigmoid(x, midpoint, width):
        # width controla la "pendiente" de la sigmoide (más pequeño = más abrupto)
        return 1 / (1 + np.exp(-(x - midpoint) / width))
    
    def day_night_cycle_profile(self, timeStep: int, noise: float = 0.0136):
        """
        Generate a day-night cycle profile for a solar panel.
        
        :param timeStep: Simulation time step in seconds
        :param low_bound: Lower bound of the cycle (0.0 for night, 0.5 for day)
        :param high_bound: Upper bound of the cycle (1.0 for night, 0.5 for day)
        :return: Day-night cycle profile
        """
        # Convert time from absolute to relative into a day, using module of a day (all in seconds)
        t = timeStep % (24 * 3600)
        
        # Sigmoide de subida: pasa de base a peak
        subida = self.base_val + (self.peak_val - self.base_val) * SolarPanel._sigmoid(t, self.rising_mid, self.transition_width)
        # Sigmoide de bajada: pasa de peak a base
        bajada = self.peak_val - (self.peak_val - self.base_val) * SolarPanel._sigmoid(t, self.falling_mid, self.transition_width)
        
        curva = np.minimum(subida, bajada)
        curva_ruido = curva + np.random.normal(0, noise)
        curva_ruido = np.clip(curva_ruido, 0, 1)
        return curva_ruido

    
    def calculate_mean_irradiance(self, timeStep: int, t_seconds: int, step_size: int = 60):
        """
        Calculate the mean irradiance of a solar panel, based on the irradiance and the time step
        :param timeStep: simulation steps in seconds (s)
        :param t_seconds: simulation time in seconds (s)
        :param step_size: step size in seconds (s) to calculate intermediate steps of the irradiance over the duration of the timeStep
        :return: Mean irradiance in kWh/m² per day
        """
        
        irrds = np.array([self.day_night_cycle_profile(i) for i in np.arange(t_seconds, t_seconds + timeStep, step_size)])
        return np.mean(irrds)

    

if __name__ == "__main__":
    # Example of usage
    # 1. Create a solar panel with the specific caracteristics:
    # Reference Solar Panel:
    # SeedStudio Panel: https://www.seeedstudio.com/Solar-Panel-PV-12W-with-mounting-bracket-p-5003.html
    # https://www.mouser.es/new/seeed-studio/seeed-studio-pv-12w-solar-panel/
    solar_panel = SolarPanel(power_rating=12, voltage_charging=14, efficiency=0.2, area=(0.35 * 0.25))
    print(f'Using irradiance of Cartagena: {solar_panel.irradiance_city["Cartagena"]}')
    print(f"Using Solar Panel: { solar_panel.__dict__}")

    # 2. Calculate the current for the selected timeStep
    # > We can select the weather of the actual step
    current_sunny = solar_panel.calculate_current(solar_irradiance=solar_panel.irradiance_city["Cartagena"], timeStep=0.5, weather_condition=Weather.SUNNY)
    current_cloudy = solar_panel.calculate_current(solar_irradiance=solar_panel.irradiance_city["Cartagena"], timeStep=0.5, weather_condition=Weather.CLOUDY)
    current_rainy = solar_panel.calculate_current(solar_irradiance=solar_panel.irradiance_city["Cartagena"], timeStep=0.5, weather_condition=Weather.RAINY)

    print(f"Current for the time step under Sunny conditions: {current_sunny} A")
    print(f"Current for the time step under Cloudy conditions: {current_cloudy} A")
    print(f"Current for the time step under Rainy conditions: {current_rainy} A")
    
    print("-----")
    # 3. Calculate the power for the selected timeStep
    # > We can select the weather of the actual step
    power_sunny = solar_panel.calculate_power_generated(solar_irradiance=solar_panel.irradiance_city["Cartagena"], timeStep=0.5, weather_condition=Weather.SUNNY)
    power_cloudy = solar_panel.calculate_power_generated(solar_irradiance=solar_panel.irradiance_city["Cartagena"], timeStep=0.5, weather_condition=Weather.CLOUDY)
    power_rainy = solar_panel.calculate_power_generated(solar_irradiance=solar_panel.irradiance_city["Cartagena"], timeStep=0.5, weather_condition=Weather.RAINY)

    print(f"Power for the time step under Sunny conditions: {power_sunny} W")
    print(f"Power for the time step under Cloudy conditions: {power_cloudy} W")
    print(f"Power for the time step under Rainy conditions: {power_rainy} W")
    
    print("-----")
    # 4. Get the Ah to charge battery
    amperes_hour_sunny = solar_panel.calculate_Ah_in_timeStep(solar_irradiance=solar_panel.irradiance_city["Cartagena"], timeStep=0.5, weather_condition=Weather.SUNNY)
    amperes_hour_cloudy = solar_panel.calculate_Ah_in_timeStep(solar_irradiance=solar_panel.irradiance_city["Cartagena"], timeStep=0.5, weather_condition=Weather.CLOUDY)
    amperes_hour_rainy = solar_panel.calculate_Ah_in_timeStep(solar_irradiance=solar_panel.irradiance_city["Cartagena"], timeStep=0.5, weather_condition=Weather.RAINY)
    print(f"Amperes hour used to charge the battery in one timeStep, sunny: {amperes_hour_sunny} Ah")
    print(f"Amperes hour used to charge the battery in one timeStep, cloudy: {amperes_hour_cloudy} Ah")
    print(f"Amperes hour used to charge the battery in one timeStep, rainy: {amperes_hour_rainy} Ah")
